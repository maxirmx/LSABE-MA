# .... LSABE access policy ...

import sys
import random

#
#  Let A be an n × l matrix and p be the function that associates rows of A with the (security?) attributes.
#  The access policy is denoted by (A,p). 

class accessPolicy:
    def __init__(self):
        self._n = 2                     # The number of columns
        self._l = 5                     # The number of rows (security attributes)

    @property
    def n(self):
        return self._n

    @property
    def l(self):
        return self._l

#  For testing simplicty I assume that A(i,0) = 1, A(i,j)=0 if j!=0 for any i
#  So no matrix is stored, I just generate a value as required 
#  Also I do not check that i is within valid range 0..l-1
    def A(self, i, j):
        if j==0:
            return 1
        return 0

# p - the function that associates rows of A with the (security?) attributes
# i - row of A, we return associated security attribute  
    def p(self,i):
        return i 

# A helper for lsabe.encrypt
# Choose a random s∈Zp and a random vector v∈Znp with s as its first entry.
    def randVector(self):
        v=[]
        for i in range(self._n):
            v.append(random.randrange(sys.maxsize)) 
        return v

# A helper for lsabe.encrypt
# For each i∈[l], we let λ(i) denote A(i)·v, where A(i) is row i of A 
# (and v - is a vector, generated by randVector)
    def lmbda(self, i, v):
        lm = 0
        for j in range (len(v)):
            lm += self.A(i,j)*v[j]
        return lm

# A helper for lsabe.transform
#  w - a set of constants {w(i)∈Zp} i∈N with Σ[w(i)*A(i)] = (1,0,...,0).
    def w(self, i):
        if i == 0:
            return 1
        return 0

